use std::path::PathBuf;

use anyhow::{Context, Result};
use baml_types::{BamlMediaType, FieldType, TypeValue};
use indexmap::IndexMap;
use internal_baml_core::{
    configuration::GeneratorDefaultClientMode,
    internal_baml_parser_database::walkers::FunctionWalker,
    ir::{
        repr::{Function, IntermediateRepr, Node, Walker},
        ClassWalker, EnumWalker, IRHelper,
    },
};
use serde::Serialize;
use serde_json::{json, value::Index};

use crate::dir_writer::{FileCollector, LanguageFeatures};

#[derive(Default)]
pub(super) struct OpenApiLanguageFeatures {}

impl LanguageFeatures for OpenApiLanguageFeatures {
    const CONTENT_PREFIX: &'static str = r#"
###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ openapi-generator generate -i openapi.yaml -g <language> -o <output_dir>
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.

        "#;
}

#[derive(Serialize)]
struct OpenApiSchema<'ir> {
    /// Always "3.0.0"
    openapi: String,
    info: serde_json::Value,
    paths: IndexMap<String, IndexMap<String, OpenApiMethodDef<'ir>>>,
    // TODO: attach BamlImage and BamlAudio here
    components: OpenApiComponents<'ir>,
}

#[derive(Serialize)]
struct OpenApiComponents<'ir> {
    schemas: IndexMap<&'ir str, OpenApiSymbolDef<'ir>>,
}

struct OpenApiMethodDef<'ir> {
    path: String,
    request_body: OpenApiClassDef<'ir>,
    response: OpenApiType<'ir>,
    // requestBody:
    // content:
    //   application/json:
    //     schema:
    //       $ref: '#/components/schemas/Order'
    // description: order placed for purchasing the pet
    // required: true
}

/// Example:
///
/// ```
/// '200':
///   content:
///     application/json:
///     schema:
///       $ref: '#/components/schemas/Pet'
/// ```
impl Serialize for OpenApiMethodDef<'_> {
    fn serialize<S: serde::Serializer>(
        &self,
        serializer: S,
    ) -> core::result::Result<S::Ok, S::Error> {
        json!({
          "requestBody": {
            "content": {
              "application/json": {
                "schema": self.request_body
              }
            }
          },
          "responses": {
            "200": {
              "description": "Successful operation",
              "content": {
                "application/json": {
                  "schema": self.response
                }
              }
            }
          }
        })
        .serialize(serializer)
    }
}

// TODO: required fields or not
#[derive(Serialize)]
struct OpenApiClassDef<'ir> {
    // name: &'ir str,
    // title: String,
    // description: String,
    /// 'type' of a Class must always be "object"
    r#type: String,
    properties: IndexMap<&'ir str, OpenApiType<'ir>>,
}

#[derive(Serialize)]
#[serde(untagged)]
enum OpenApiSymbolDef<'ir> {
    Class {
        // name: &'ir str,
        // title: String,
        // description: String,
        /// 'type' of a Class must always be "object"
        r#type: String,
        properties: IndexMap<&'ir str, OpenApiType<'ir>>,
    },
    Enum {
        r#type: String,
        r#enum: Vec<&'ir str>,
    },
}

#[derive(Serialize)]
#[serde(untagged)]
enum OpenApiType<'ir> {
    Def {
        r#type: &'ir str,
        #[serde(skip_serializing_if = "Option::is_none")]
        format: Option<&'ir str>,
    },
    Array {
        /// 'type' of an Array must always be "array"
        r#type: String,
        items: Box<OpenApiType<'ir>>,
    },
    /// key type must always be "string"
    #[serde(rename_all = "camelCase")]
    Map {
        /// 'type' of a Map must always be "object"
        r#type: String,
        /// value type
        additional_properties: Box<OpenApiType<'ir>>,
    },
    Ref {
        #[serde(rename = "$ref")]
        r#ref: String,
    },
    /// https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/
    #[serde(rename_all = "camelCase")]
    Union { any_of: Vec<OpenApiType<'ir>> },
}

pub(crate) fn generate(
    ir: &IntermediateRepr,
    generator: &crate::GeneratorArgs,
) -> Result<IndexMap<PathBuf, String>> {
    let mut collector = FileCollector::<OpenApiLanguageFeatures>::new();

    let schema: OpenApiSchema = (ir, generator).try_into()?;

    collector.add_file("openapi.yaml", serde_yaml::to_string(&schema)?);

    collector.commit(&generator.output_dir())
}

impl<'ir> TryFrom<(&'ir IntermediateRepr, &'_ crate::GeneratorArgs)> for OpenApiSchema<'ir> {
    type Error = anyhow::Error;

    fn try_from((ir, _): (&'ir IntermediateRepr, &'_ crate::GeneratorArgs)) -> Result<Self> {
        Ok(Self {
            openapi: "3.0.0".to_string(),
            info: json!({
              "description": "baml-cli serve",
              "version": "0.1.0",
              "title": "baml-cli serve",
            }),
            paths: ir
                .walk_functions()
                .map(|f| {
                    let mut methods = IndexMap::new();
                    methods.insert("post".to_string(), f.try_into()?);

                    Ok((format!("/call/{}", f.name()), methods))
                })
                .collect::<Result<_>>()?,
            components: OpenApiComponents {
                schemas: vec![
                    (
                        "BamlImage",
                        OpenApiSymbolDef::Class {
                            r#type: "object".to_string(),
                            properties: vec![(
                                "base64",
                                OpenApiType::Def {
                                    r#type: "string",
                                    format: None,
                                },
                            )]
                            .into_iter()
                            .collect(),
                        },
                    ),
                    (
                        "BamlAudio",
                        OpenApiSymbolDef::Class {
                            r#type: "object".to_string(),
                            properties: vec![(
                                "base64",
                                OpenApiType::Def {
                                    r#type: "string",
                                    format: None,
                                },
                            )]
                            .into_iter()
                            .collect(),
                        },
                    ),
                ]
                .into_iter()
                .map(Ok)
                .chain(ir.walk_enums().map(|e| Ok((e.name(), e.try_into()?))))
                .chain(ir.walk_classes().map(|c| Ok((c.name(), c.try_into()?))))
                .collect::<Result<_>>()?,
            },
        })
    }
}

impl<'ir> TryFrom<Walker<'ir, &'ir Node<Function>>> for OpenApiMethodDef<'ir> {
    type Error = anyhow::Error;

    fn try_from(value: Walker<'ir, &'ir Node<Function>>) -> Result<Self> {
        Ok(Self {
            path: format!("/call/{}", value.item.elem.name()),
            request_body: OpenApiClassDef {
                r#type: "object".to_string(),
                properties: value
                    .item
                    .elem
                    .inputs()
                    .iter()
                    .map(|(name, t)| -> Result<(&str, OpenApiType)> {
                        Ok((name.as_str(), t.to_type_ref(value.db)?))
                    })
                    .collect::<Result<_>>()?,
            },
            response: value.item.elem.output().to_type_ref(value.db)?,
        })
    }
}

impl<'ir> TryFrom<EnumWalker<'ir>> for OpenApiSymbolDef<'ir> {
    type Error = anyhow::Error;

    fn try_from(e: EnumWalker<'ir>) -> Result<Self> {
        Ok(OpenApiSymbolDef::Enum {
            // name: c.name(),
            r#type: "string".to_string(),
            r#enum: e
                .item
                .elem
                .values
                .iter()
                .map(|v| v.elem.0.as_str())
                .collect(),
        })
    }
}

impl<'ir> TryFrom<ClassWalker<'ir>> for OpenApiSymbolDef<'ir> {
    type Error = anyhow::Error;

    fn try_from(c: ClassWalker<'ir>) -> Result<Self> {
        Ok(OpenApiSymbolDef::Class {
            // name: c.name(),
            r#type: "object".to_string(),
            properties: c
                .item
                .elem
                .static_fields
                .iter()
                .map(|f| -> Result<(&str, OpenApiType)> {
                    Ok((
                        f.elem.name.as_str(),
                        f.elem.r#type.elem.to_type_ref(&c.db).context(format!(
                            "Failed to convert {} to OpenAPI type",
                            f.elem.name
                        ))?,
                    ))
                })
                .collect::<Result<_>>()?,
        })
    }
}

impl<'ir> TryFrom<ClassWalker<'ir>> for OpenApiClassDef<'ir> {
    type Error = anyhow::Error;

    fn try_from(c: ClassWalker<'ir>) -> Result<Self> {
        Ok(Self {
            // name: c.name(),
            r#type: "object".to_string(),
            properties: c
                .item
                .elem
                .static_fields
                .iter()
                .map(|f| -> Result<(&str, OpenApiType)> {
                    Ok((
                        f.elem.name.as_str(),
                        f.elem.r#type.elem.to_type_ref(&c.db).context(format!(
                            "Failed to convert {} to OpenAPI type",
                            f.elem.name
                        ))?,
                    ))
                })
                .collect::<Result<_>>()?,
        })
    }
}

trait ToTypeReferenceInTypeDefinition<'ir> {
    fn to_type_ref(&self, ir: &'ir IntermediateRepr) -> Result<OpenApiType<'ir>>;
    fn to_partial_type_ref(
        &self,
        ir: &'ir IntermediateRepr,
        wrapped: bool,
    ) -> Result<OpenApiType<'ir>>;
}

impl<'ir> ToTypeReferenceInTypeDefinition<'ir> for FieldType {
    fn to_type_ref(&self, ir: &'ir IntermediateRepr) -> Result<OpenApiType<'ir>> {
        Ok(match self {
            FieldType::Enum(name) | FieldType::Class(name) => OpenApiType::Ref {
                r#ref: format!("#/components/schemas/{}", name),
            },
            FieldType::List(inner) => OpenApiType::Array {
                r#type: "array".to_string(),
                items: Box::new(inner.to_type_ref(ir)?),
            },
            FieldType::Map(key, value) => match **key {
                FieldType::Primitive(TypeValue::String) => OpenApiType::Map {
                    r#type: "object".to_string(),
                    additional_properties: Box::new(value.to_type_ref(ir)?),
                },
                _ => anyhow::bail!("BAML<->OpenAPI only supports string keys in maps"),
            },
            FieldType::Primitive(inner) => match inner {
                TypeValue::Bool => OpenApiType::Def {
                    r#type: "boolean",
                    format: None,
                },
                TypeValue::Float => OpenApiType::Def {
                    r#type: "number",
                    format: Some("double"),
                },
                TypeValue::Int => OpenApiType::Def {
                    r#type: "integer",
                    // TODO: is this desirable? or would we rather just do int32?
                    format: Some("int64"),
                },
                TypeValue::Null => anyhow::bail!("OpenAPI does not support null literals"),
                TypeValue::String => OpenApiType::Def {
                    r#type: "string",
                    format: None,
                },
                TypeValue::Media(BamlMediaType::Audio) => OpenApiType::Ref {
                    r#ref: format!("#/components/schemas/BamlAudio"),
                },
                TypeValue::Media(BamlMediaType::Image) => OpenApiType::Ref {
                    r#ref: format!("#/components/schemas/BamlImage"),
                },
            },
            FieldType::Union(inner) => OpenApiType::Union {
                any_of: inner
                    .iter()
                    .map(|t| t.to_type_ref(ir))
                    .collect::<Result<_>>()?,
            },
            FieldType::Tuple(inner) => {
                anyhow::bail!("BAML<->OpenAPI tuple support is not implemented")
            }
            // TODO: optional is not implemented correctly
            FieldType::Optional(inner) => inner.to_type_ref(ir)?,
        })
    }

    fn to_partial_type_ref(
        &self,
        ir: &'ir IntermediateRepr,
        wrapped: bool,
    ) -> Result<OpenApiType<'ir>> {
        Ok(match self {
            FieldType::Enum(name) => OpenApiType::Def {
                r#type: "string",
                format: Some("enum"),
            },
            FieldType::Class(name) => OpenApiType::Def {
                r#type: "string",
                format: Some("enum"),
            },
            FieldType::List(inner) => unimplemented!(),
            FieldType::Map(key, value) => unimplemented!(),
            FieldType::Primitive(inner) => unimplemented!(),
            FieldType::Union(inner) => unimplemented!(),
            FieldType::Tuple(inner) => unimplemented!(),
            FieldType::Optional(inner) => unimplemented!(),
        })
    }
}
